### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type AuthPayload {
  token: String!
  user: User!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

enum Category {
  ABSTRACT
  FLORAL
  INDIAN
  LANDSCAPE
  PORTRAIT
}

type Collection {
  id: Int!
  name: String!
  users(skip: Int, where: UserWhereInput): [User!]!
  works(skip: Int): [Work!]!
}

input CollectionCreateInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  WorkOrder: WorkOrderCreateManyWithoutCollectionInput
  works: WorkCreateManyWithoutCollectionsInput
}

input CollectionCreateManyWithoutWorksInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutWorksInput!]
}

input CollectionCreateOneWithoutWorkOrderInput {
  connect: CollectionWhereUniqueInput
  create: CollectionCreateWithoutWorkOrderInput
}

input CollectionCreateWithoutWorkOrderInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  works: WorkCreateManyWithoutCollectionsInput
}

input CollectionCreateWithoutWorksInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  WorkOrder: WorkOrderCreateManyWithoutCollectionInput
}

input CollectionListRelationFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

input CollectionOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input CollectionScalarWhereInput {
  AND: [CollectionScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  updatedAt: DateTimeNullableFilter
}

input CollectionUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  users: UserUpdateManyWithoutCollectionsInput
  WorkOrder: WorkOrderUpdateManyWithoutCollectionInput
  works: WorkUpdateManyWithoutCollectionsInput
}

input CollectionUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input CollectionUpdateManyWithoutWorksInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutWorksInput!]
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutWorksInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutWorksInput!]
}

input CollectionUpdateManyWithWhereNestedInput {
  data: CollectionUpdateManyDataInput!
  where: CollectionScalarWhereInput!
}

input CollectionUpdateOneRequiredWithoutWorkOrderInput {
  connect: CollectionWhereUniqueInput
  create: CollectionCreateWithoutWorkOrderInput
  update: CollectionUpdateWithoutWorkOrderDataInput
  upsert: CollectionUpsertWithoutWorkOrderInput
}

input CollectionUpdateWithoutWorkOrderDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  users: UserUpdateManyWithoutCollectionsInput
  works: WorkUpdateManyWithoutCollectionsInput
}

input CollectionUpdateWithoutWorksDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  users: UserUpdateManyWithoutCollectionsInput
  WorkOrder: WorkOrderUpdateManyWithoutCollectionInput
}

input CollectionUpdateWithWhereUniqueWithoutWorksInput {
  data: CollectionUpdateWithoutWorksDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutWorkOrderInput {
  create: CollectionCreateWithoutWorkOrderInput!
  update: CollectionUpdateWithoutWorkOrderDataInput!
}

input CollectionUpsertWithWhereUniqueWithoutWorksInput {
  create: CollectionCreateWithoutWorksInput!
  update: CollectionUpdateWithoutWorksDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  updatedAt: DateTimeNullableFilter
  users: UserListRelationFilter
  WorkOrder: WorkOrderListRelationFilter
  works: WorkListRelationFilter
}

input CollectionWhereUniqueInput {
  id: Int
  name: String
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

type Image {
  height: Int
  id: Int!
  name: String!
  url: String!
  width: Int
  workId: Int!
}

input ImageCreateManyWithoutWorkInput {
  connect: [ImageWhereUniqueInput!]
  create: [ImageCreateWithoutWorkInput!]
}

input ImageCreateWithoutWorkInput {
  createdAt: DateTime
  height: Int
  name: String!
  updatedAt: DateTime
  url: String!
  width: Int
}

input ImageListRelationFilter {
  every: ImageWhereInput
  none: ImageWhereInput
  some: ImageWhereInput
}

input ImageScalarWhereInput {
  AND: [ImageScalarWhereInput!]
  createdAt: DateTimeFilter
  height: IntNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  updatedAt: DateTimeNullableFilter
  url: StringFilter
  width: IntNullableFilter
  workId: IntFilter
}

input ImageUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  height: NullableIntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  width: NullableIntFieldUpdateOperationsInput
}

input ImageUpdateManyWithoutWorkInput {
  connect: [ImageWhereUniqueInput!]
  create: [ImageCreateWithoutWorkInput!]
  delete: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  disconnect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  update: [ImageUpdateWithWhereUniqueWithoutWorkInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueWithoutWorkInput!]
}

input ImageUpdateManyWithWhereNestedInput {
  data: ImageUpdateManyDataInput!
  where: ImageScalarWhereInput!
}

input ImageUpdateWithoutWorkDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  height: NullableIntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
  width: NullableIntFieldUpdateOperationsInput
}

input ImageUpdateWithWhereUniqueWithoutWorkInput {
  data: ImageUpdateWithoutWorkDataInput!
  where: ImageWhereUniqueInput!
}

input ImageUpsertWithWhereUniqueWithoutWorkInput {
  create: ImageCreateWithoutWorkInput!
  update: ImageUpdateWithoutWorkDataInput!
  where: ImageWhereUniqueInput!
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  createdAt: DateTimeFilter
  height: IntNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  updatedAt: DateTimeNullableFilter
  url: StringFilter
  width: IntNullableFilter
  work: WorkWhereInput
  workId: IntFilter
}

input ImageWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Mutation {
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneWork(where: WorkWhereUniqueInput!): Work
  login(password: String, username: String): AuthPayload!
  register(email: String, name: String, password: String): AuthPayload!
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneWork(create: WorkCreateInput!, update: WorkUpdateInput!, where: WorkWhereUniqueInput!): Work!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableBoolFieldUpdateOperationsInput {
  set: Boolean
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
  set: Float
}

input NullableIntFieldUpdateOperationsInput {
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Phone {
  id: Int!
  number: String!
  profile: Profile!
  profileId: Int!
  type: PhoneType!
}

input PhoneCreateManyWithoutProfileInput {
  connect: [PhoneWhereUniqueInput!]
  create: [PhoneCreateWithoutProfileInput!]
}

input PhoneCreateWithoutProfileInput {
  number: String!
  type: PhoneType
}

input PhoneListRelationFilter {
  every: PhoneWhereInput
  none: PhoneWhereInput
  some: PhoneWhereInput
}

input PhoneScalarWhereInput {
  AND: [PhoneScalarWhereInput!]
  id: IntFilter
  NOT: [PhoneScalarWhereInput!]
  number: StringFilter
  OR: [PhoneScalarWhereInput!]
  profileId: IntFilter
  type: PhoneType
}

enum PhoneType {
  COMPANY
  MOBILE
  PERSONAL
  WORK
}

input PhoneUpdateManyDataInput {
  number: StringFieldUpdateOperationsInput
  type: PhoneType
}

input PhoneUpdateManyWithoutProfileInput {
  connect: [PhoneWhereUniqueInput!]
  create: [PhoneCreateWithoutProfileInput!]
  delete: [PhoneWhereUniqueInput!]
  deleteMany: [PhoneScalarWhereInput!]
  disconnect: [PhoneWhereUniqueInput!]
  set: [PhoneWhereUniqueInput!]
  update: [PhoneUpdateWithWhereUniqueWithoutProfileInput!]
  updateMany: [PhoneUpdateManyWithWhereNestedInput!]
  upsert: [PhoneUpsertWithWhereUniqueWithoutProfileInput!]
}

input PhoneUpdateManyWithWhereNestedInput {
  data: PhoneUpdateManyDataInput!
  where: PhoneScalarWhereInput!
}

input PhoneUpdateWithoutProfileDataInput {
  number: StringFieldUpdateOperationsInput
  type: PhoneType
}

input PhoneUpdateWithWhereUniqueWithoutProfileInput {
  data: PhoneUpdateWithoutProfileDataInput!
  where: PhoneWhereUniqueInput!
}

input PhoneUpsertWithWhereUniqueWithoutProfileInput {
  create: PhoneCreateWithoutProfileInput!
  update: PhoneUpdateWithoutProfileDataInput!
  where: PhoneWhereUniqueInput!
}

input PhoneWhereInput {
  AND: [PhoneWhereInput!]
  id: IntFilter
  NOT: [PhoneWhereInput!]
  number: StringFilter
  OR: [PhoneWhereInput!]
  profile: ProfileWhereInput
  profileId: IntFilter
  type: PhoneType
}

input PhoneWhereUniqueInput {
  id: Int
}

type Profile {
  companyName: String
  id: Int!
  user: User!
  userId: Int!
  website: String
}

input ProfileCreateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateWithoutUserInput {
  companyName: String
  companyRole: String
  phone: PhoneCreateManyWithoutProfileInput
  updatedAt: DateTime
  website: String
}

input ProfileUpdateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserDataInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserDataInput {
  companyName: NullableStringFieldUpdateOperationsInput
  companyRole: NullableStringFieldUpdateOperationsInput
  phone: PhoneUpdateManyWithoutProfileInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  companyName: StringNullableFilter
  companyRole: StringNullableFilter
  id: IntFilter
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  phone: PhoneListRelationFilter
  updatedAt: DateTimeNullableFilter
  user: UserWhereInput
  userId: IntFilter
  website: StringNullableFilter
}

input ProfileWhereUniqueInput {
  id: Int
}

type Query {
  allCollections(orderBy: [CollectionOrderByInput!], skip: Int, where: CollectionWhereInput): [Collection!]!
  allUsers(orderBy: [UserOrderByInput!], skip: Int, where: UserWhereInput): [User!]!
  allWorks(orderBy: [WorkOrderByInput!], skip: Int, where: WorkWhereInput): [Work!]!
  collection(where: CollectionWhereUniqueInput!): Collection
  empty: Boolean
  me: User
  work(where: WorkWhereUniqueInput!): Work
  worksByCollection(after: Int, before: Int, first: Int, last: Int, orderBy: WorkOrderByInput, skip: Int, where: CollectionWhereInput): Collection!
}

enum Role {
  ADMIN
  MANAGER
  SUPER
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum Type {
  MIXED
  PAINTING
  SCULPTURE
}

type User {
  collections(skip: Int): [Collection!]!
  display: String
  email: String!
  id: Int!
  profile: Profile
  role: Role!
  username: String!
}

input UserCreateManyWithoutCollectionsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCollectionsInput!]
}

input UserCreateWithoutCollectionsInput {
  createdAt: DateTime
  display: String
  email: String!
  password: String!
  profile: ProfileCreateOneWithoutUserInput
  role: Role
  updatedAt: DateTime
  username: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  createdAt: SortOrder
  display: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  display: StringNullableFilter
  email: StringFilter
  id: IntFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  role: Role
  updatedAt: DateTimeNullableFilter
  username: StringFilter
}

input UserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  display: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: Role
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithoutCollectionsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCollectionsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCollectionsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCollectionsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutCollectionsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  display: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserInput
  role: Role
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithWhereUniqueWithoutCollectionsInput {
  data: UserUpdateWithoutCollectionsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutCollectionsInput {
  create: UserCreateWithoutCollectionsInput!
  update: UserUpdateWithoutCollectionsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  collections: CollectionListRelationFilter
  createdAt: DateTimeFilter
  display: StringNullableFilter
  email: StringFilter
  id: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  profile: ProfileWhereInput
  role: Role
  updatedAt: DateTimeNullableFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  username: String
}

type Work {
  catalogId: Int!
  category: Category!
  collections(skip: Int, where: CollectionWhereInput): [Collection!]!
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int!
  medium: String
  price: Float
  title: String!
  type: Type!
  width: Float
}

type WorkConnection {
  cursor: String
  hasMore: Boolean!
  works: [Work]!
}

input WorkCreateInput {
  catalogId: Int!
  category: Category
  collections: CollectionCreateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
  WorkOrder: WorkOrderCreateManyWithoutWorkInput
}

input WorkCreateManyWithoutCollectionsInput {
  connect: [WorkWhereUniqueInput!]
  create: [WorkCreateWithoutCollectionsInput!]
}

input WorkCreateOneWithoutWorkOrderInput {
  connect: WorkWhereUniqueInput
  create: WorkCreateWithoutWorkOrderInput
}

input WorkCreateWithoutCollectionsInput {
  catalogId: Int!
  category: Category
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
  WorkOrder: WorkOrderCreateManyWithoutWorkInput
}

input WorkCreateWithoutWorkOrderInput {
  catalogId: Int!
  category: Category
  collections: CollectionCreateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
}

input WorkListRelationFilter {
  every: WorkWhereInput
  none: WorkWhereInput
  some: WorkWhereInput
}

type WorkOrder {
  collectionId: Int!
  order: Int!
  workId: Int!
}

input WorkOrderByInput {
  catalogId: SortOrder
  category: SortOrder
  createdAt: SortOrder
  date: SortOrder
  dimensions: SortOrder
  framed: SortOrder
  height: SortOrder
  id: SortOrder
  medium: SortOrder
  price: SortOrder
  published: SortOrder
  title: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  width: SortOrder
}

input WorkOrderCreateManyWithoutCollectionInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutCollectionInput!]
}

input WorkOrderCreateManyWithoutWorkInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutWorkInput!]
}

input WorkOrderCreateWithoutCollectionInput {
  order: Int!
  work: WorkCreateOneWithoutWorkOrderInput!
}

input WorkOrderCreateWithoutWorkInput {
  collection: CollectionCreateOneWithoutWorkOrderInput!
  order: Int!
}

input WorkOrderListRelationFilter {
  every: WorkOrderWhereInput
  none: WorkOrderWhereInput
  some: WorkOrderWhereInput
}

input WorkOrderScalarWhereInput {
  AND: [WorkOrderScalarWhereInput!]
  collectionId: IntFilter
  id: IntFilter
  NOT: [WorkOrderScalarWhereInput!]
  OR: [WorkOrderScalarWhereInput!]
  order: IntFilter
  workId: IntFilter
}

input WorkOrderUpdateManyDataInput {
  order: IntFieldUpdateOperationsInput
}

input WorkOrderUpdateManyWithoutCollectionInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutCollectionInput!]
  delete: [WorkOrderWhereUniqueInput!]
  deleteMany: [WorkOrderScalarWhereInput!]
  disconnect: [WorkOrderWhereUniqueInput!]
  set: [WorkOrderWhereUniqueInput!]
  update: [WorkOrderUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [WorkOrderUpdateManyWithWhereNestedInput!]
  upsert: [WorkOrderUpsertWithWhereUniqueWithoutCollectionInput!]
}

input WorkOrderUpdateManyWithoutWorkInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutWorkInput!]
  delete: [WorkOrderWhereUniqueInput!]
  deleteMany: [WorkOrderScalarWhereInput!]
  disconnect: [WorkOrderWhereUniqueInput!]
  set: [WorkOrderWhereUniqueInput!]
  update: [WorkOrderUpdateWithWhereUniqueWithoutWorkInput!]
  updateMany: [WorkOrderUpdateManyWithWhereNestedInput!]
  upsert: [WorkOrderUpsertWithWhereUniqueWithoutWorkInput!]
}

input WorkOrderUpdateManyWithWhereNestedInput {
  data: WorkOrderUpdateManyDataInput!
  where: WorkOrderScalarWhereInput!
}

input WorkOrderUpdateWithoutCollectionDataInput {
  order: IntFieldUpdateOperationsInput
  work: WorkUpdateOneRequiredWithoutWorkOrderInput
}

input WorkOrderUpdateWithoutWorkDataInput {
  collection: CollectionUpdateOneRequiredWithoutWorkOrderInput
  order: IntFieldUpdateOperationsInput
}

input WorkOrderUpdateWithWhereUniqueWithoutCollectionInput {
  data: WorkOrderUpdateWithoutCollectionDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpdateWithWhereUniqueWithoutWorkInput {
  data: WorkOrderUpdateWithoutWorkDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpsertWithWhereUniqueWithoutCollectionInput {
  create: WorkOrderCreateWithoutCollectionInput!
  update: WorkOrderUpdateWithoutCollectionDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpsertWithWhereUniqueWithoutWorkInput {
  create: WorkOrderCreateWithoutWorkInput!
  update: WorkOrderUpdateWithoutWorkDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderWhereInput {
  AND: [WorkOrderWhereInput!]
  collection: CollectionWhereInput
  collectionId: IntFilter
  id: IntFilter
  NOT: [WorkOrderWhereInput!]
  OR: [WorkOrderWhereInput!]
  order: IntFilter
  work: WorkWhereInput
  workId: IntFilter
}

input WorkOrderWhereUniqueInput {
  id: Int
}

input WorkScalarWhereInput {
  AND: [WorkScalarWhereInput!]
  catalogId: IntFilter
  category: Category
  createdAt: DateTimeFilter
  date: StringNullableFilter
  dimensions: StringNullableFilter
  framed: BoolNullableFilter
  height: FloatNullableFilter
  id: IntFilter
  medium: StringNullableFilter
  NOT: [WorkScalarWhereInput!]
  OR: [WorkScalarWhereInput!]
  price: FloatNullableFilter
  published: BoolFilter
  title: StringFilter
  type: Type
  updatedAt: DateTimeNullableFilter
  width: FloatNullableFilter
}

input WorkUpdateInput {
  catalogId: IntFieldUpdateOperationsInput
  category: Category
  collections: CollectionUpdateManyWithoutWorksInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: NullableStringFieldUpdateOperationsInput
  dimensions: NullableStringFieldUpdateOperationsInput
  framed: NullableBoolFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  image: ImageUpdateManyWithoutWorkInput
  medium: NullableStringFieldUpdateOperationsInput
  price: NullableFloatFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: Type
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
  WorkOrder: WorkOrderUpdateManyWithoutWorkInput
}

input WorkUpdateManyDataInput {
  catalogId: IntFieldUpdateOperationsInput
  category: Category
  createdAt: DateTimeFieldUpdateOperationsInput
  date: NullableStringFieldUpdateOperationsInput
  dimensions: NullableStringFieldUpdateOperationsInput
  framed: NullableBoolFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  medium: NullableStringFieldUpdateOperationsInput
  price: NullableFloatFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: Type
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
}

input WorkUpdateManyWithoutCollectionsInput {
  connect: [WorkWhereUniqueInput!]
  create: [WorkCreateWithoutCollectionsInput!]
  delete: [WorkWhereUniqueInput!]
  deleteMany: [WorkScalarWhereInput!]
  disconnect: [WorkWhereUniqueInput!]
  set: [WorkWhereUniqueInput!]
  update: [WorkUpdateWithWhereUniqueWithoutCollectionsInput!]
  updateMany: [WorkUpdateManyWithWhereNestedInput!]
  upsert: [WorkUpsertWithWhereUniqueWithoutCollectionsInput!]
}

input WorkUpdateManyWithWhereNestedInput {
  data: WorkUpdateManyDataInput!
  where: WorkScalarWhereInput!
}

input WorkUpdateOneRequiredWithoutWorkOrderInput {
  connect: WorkWhereUniqueInput
  create: WorkCreateWithoutWorkOrderInput
  update: WorkUpdateWithoutWorkOrderDataInput
  upsert: WorkUpsertWithoutWorkOrderInput
}

input WorkUpdateWithoutCollectionsDataInput {
  catalogId: IntFieldUpdateOperationsInput
  category: Category
  createdAt: DateTimeFieldUpdateOperationsInput
  date: NullableStringFieldUpdateOperationsInput
  dimensions: NullableStringFieldUpdateOperationsInput
  framed: NullableBoolFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  image: ImageUpdateManyWithoutWorkInput
  medium: NullableStringFieldUpdateOperationsInput
  price: NullableFloatFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: Type
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
  WorkOrder: WorkOrderUpdateManyWithoutWorkInput
}

input WorkUpdateWithoutWorkOrderDataInput {
  catalogId: IntFieldUpdateOperationsInput
  category: Category
  collections: CollectionUpdateManyWithoutWorksInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: NullableStringFieldUpdateOperationsInput
  dimensions: NullableStringFieldUpdateOperationsInput
  framed: NullableBoolFieldUpdateOperationsInput
  height: NullableFloatFieldUpdateOperationsInput
  image: ImageUpdateManyWithoutWorkInput
  medium: NullableStringFieldUpdateOperationsInput
  price: NullableFloatFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: Type
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
  width: NullableFloatFieldUpdateOperationsInput
}

input WorkUpdateWithWhereUniqueWithoutCollectionsInput {
  data: WorkUpdateWithoutCollectionsDataInput!
  where: WorkWhereUniqueInput!
}

input WorkUpsertWithoutWorkOrderInput {
  create: WorkCreateWithoutWorkOrderInput!
  update: WorkUpdateWithoutWorkOrderDataInput!
}

input WorkUpsertWithWhereUniqueWithoutCollectionsInput {
  create: WorkCreateWithoutCollectionsInput!
  update: WorkUpdateWithoutCollectionsDataInput!
  where: WorkWhereUniqueInput!
}

input WorkWhereInput {
  AND: [WorkWhereInput!]
  catalogId: IntFilter
  category: Category
  collections: CollectionListRelationFilter
  createdAt: DateTimeFilter
  date: StringNullableFilter
  dimensions: StringNullableFilter
  framed: BoolNullableFilter
  height: FloatNullableFilter
  id: IntFilter
  image: ImageListRelationFilter
  medium: StringNullableFilter
  NOT: [WorkWhereInput!]
  OR: [WorkWhereInput!]
  price: FloatNullableFilter
  published: BoolFilter
  title: StringFilter
  type: Type
  updatedAt: DateTimeNullableFilter
  width: FloatNullableFilter
  WorkOrder: WorkOrderListRelationFilter
}

input WorkWhereUniqueInput {
  catalogId: Int
  id: Int
}
