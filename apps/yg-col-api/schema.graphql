### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type AuthPayload {
  token: String!
  user: User!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

enum Category {
  ABSTRACT
  FLORAL
  INDIAN
  LANDSCAPE
  PORTRAIT
}

type Collection {
  id: Int!
  name: String!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, skip: Int, where: UserWhereInput): [User!]!
  workOrder(after: WorkOrderWhereUniqueInput, before: WorkOrderWhereUniqueInput, first: Int, last: Int, skip: Int): [WorkOrder!]!
  works(after: WorkWhereUniqueInput, before: WorkWhereUniqueInput, first: Int, last: Int, skip: Int): [Work!]!
}

input CollectionCreateInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  workOrder: WorkOrderCreateManyWithoutCollectionInput
  works: WorkCreateManyWithoutCollectionsInput
}

input CollectionCreateManyWithoutWorksInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutWorksInput!]
}

input CollectionCreateOneWithoutWorkOrderInput {
  connect: CollectionWhereUniqueInput
  create: CollectionCreateWithoutWorkOrderInput
}

input CollectionCreateWithoutWorkOrderInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  works: WorkCreateManyWithoutCollectionsInput
}

input CollectionCreateWithoutWorksInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutCollectionsInput
  workOrder: WorkOrderCreateManyWithoutCollectionInput
}

input CollectionFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

input CollectionOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  name: OrderByArg
  updatedAt: OrderByArg
}

input CollectionScalarWhereInput {
  AND: [CollectionScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  updatedAt: NullableDateTimeFilter
  users: UserFilter
  workOrder: WorkOrderFilter
  works: WorkFilter
}

input CollectionUpdateInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutCollectionsInput
  workOrder: WorkOrderUpdateManyWithoutCollectionInput
  works: WorkUpdateManyWithoutCollectionsInput
}

input CollectionUpdateManyDataInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input CollectionUpdateManyWithoutWorksInput {
  connect: [CollectionWhereUniqueInput!]
  create: [CollectionCreateWithoutWorksInput!]
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutWorksInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutWorksInput!]
}

input CollectionUpdateManyWithWhereNestedInput {
  data: CollectionUpdateManyDataInput!
  where: CollectionScalarWhereInput!
}

input CollectionUpdateOneRequiredWithoutWorkOrderInput {
  connect: CollectionWhereUniqueInput
  create: CollectionCreateWithoutWorkOrderInput
  update: CollectionUpdateWithoutWorkOrderDataInput
  upsert: CollectionUpsertWithoutWorkOrderInput
}

input CollectionUpdateWithoutWorkOrderDataInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutCollectionsInput
  works: WorkUpdateManyWithoutCollectionsInput
}

input CollectionUpdateWithoutWorksDataInput {
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutCollectionsInput
  workOrder: WorkOrderUpdateManyWithoutCollectionInput
}

input CollectionUpdateWithWhereUniqueWithoutWorksInput {
  data: CollectionUpdateWithoutWorksDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutWorkOrderInput {
  create: CollectionCreateWithoutWorkOrderInput!
  update: CollectionUpdateWithoutWorkOrderDataInput!
}

input CollectionUpsertWithWhereUniqueWithoutWorksInput {
  create: CollectionCreateWithoutWorksInput!
  update: CollectionUpdateWithoutWorksDataInput!
  where: CollectionWhereUniqueInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  updatedAt: NullableDateTimeFilter
  users: UserFilter
  workOrder: WorkOrderFilter
  works: WorkFilter
}

input CollectionWhereUniqueInput {
  id: Int
  name: String
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Image {
  height: Int
  id: Int!
  name: String!
  url: String!
  width: Int
  workId: Int!
}

input ImageCreateManyWithoutWorkInput {
  connect: [ImageWhereUniqueInput!]
  create: [ImageCreateWithoutWorkInput!]
}

input ImageCreateWithoutWorkInput {
  createdAt: DateTime
  height: Int
  name: String!
  updatedAt: DateTime
  url: String!
  width: Int
}

input ImageFilter {
  every: ImageWhereInput
  none: ImageWhereInput
  some: ImageWhereInput
}

input ImageScalarWhereInput {
  AND: [ImageScalarWhereInput!]
  createdAt: DateTimeFilter
  height: NullableIntFilter
  id: IntFilter
  name: StringFilter
  NOT: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  updatedAt: NullableDateTimeFilter
  url: StringFilter
  width: NullableIntFilter
  workId: IntFilter
}

input ImageUpdateManyDataInput {
  createdAt: DateTime
  height: Int
  id: Int
  name: String
  updatedAt: DateTime
  url: String
  width: Int
}

input ImageUpdateManyWithoutWorkInput {
  connect: [ImageWhereUniqueInput!]
  create: [ImageCreateWithoutWorkInput!]
  delete: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  disconnect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  update: [ImageUpdateWithWhereUniqueWithoutWorkInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueWithoutWorkInput!]
}

input ImageUpdateManyWithWhereNestedInput {
  data: ImageUpdateManyDataInput!
  where: ImageScalarWhereInput!
}

input ImageUpdateWithoutWorkDataInput {
  createdAt: DateTime
  height: Int
  id: Int
  name: String
  updatedAt: DateTime
  url: String
  width: Int
}

input ImageUpdateWithWhereUniqueWithoutWorkInput {
  data: ImageUpdateWithoutWorkDataInput!
  where: ImageWhereUniqueInput!
}

input ImageUpsertWithWhereUniqueWithoutWorkInput {
  create: ImageCreateWithoutWorkInput!
  update: ImageUpdateWithoutWorkDataInput!
  where: ImageWhereUniqueInput!
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  createdAt: DateTimeFilter
  height: NullableIntFilter
  id: IntFilter
  name: StringFilter
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  updatedAt: NullableDateTimeFilter
  url: StringFilter
  width: NullableIntFilter
  work: WorkWhereInput
  workId: IntFilter
}

input ImageWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneWork(where: WorkWhereUniqueInput!): Work
  login(password: String, username: String): AuthPayload!
  register(email: String, name: String, password: String): AuthPayload!
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneWork(create: WorkCreateInput!, update: WorkUpdateInput!, where: WorkWhereUniqueInput!): Work!
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Phone {
  id: Int!
  number: String!
  profile: Profile!
  profileId: Int!
  type: PhoneType!
}

input PhoneCreateManyWithoutProfileInput {
  connect: [PhoneWhereUniqueInput!]
  create: [PhoneCreateWithoutProfileInput!]
}

input PhoneCreateWithoutProfileInput {
  number: String!
  type: PhoneType
}

input PhoneFilter {
  every: PhoneWhereInput
  none: PhoneWhereInput
  some: PhoneWhereInput
}

input PhoneScalarWhereInput {
  AND: [PhoneScalarWhereInput!]
  id: IntFilter
  NOT: [PhoneScalarWhereInput!]
  number: StringFilter
  OR: [PhoneScalarWhereInput!]
  profileId: IntFilter
  type: PhoneType
}

enum PhoneType {
  COMPANY
  MOBILE
  PERSONAL
  WORK
}

input PhoneUpdateManyDataInput {
  id: Int
  number: String
  type: PhoneType
}

input PhoneUpdateManyWithoutProfileInput {
  connect: [PhoneWhereUniqueInput!]
  create: [PhoneCreateWithoutProfileInput!]
  delete: [PhoneWhereUniqueInput!]
  deleteMany: [PhoneScalarWhereInput!]
  disconnect: [PhoneWhereUniqueInput!]
  set: [PhoneWhereUniqueInput!]
  update: [PhoneUpdateWithWhereUniqueWithoutProfileInput!]
  updateMany: [PhoneUpdateManyWithWhereNestedInput!]
  upsert: [PhoneUpsertWithWhereUniqueWithoutProfileInput!]
}

input PhoneUpdateManyWithWhereNestedInput {
  data: PhoneUpdateManyDataInput!
  where: PhoneScalarWhereInput!
}

input PhoneUpdateWithoutProfileDataInput {
  id: Int
  number: String
  type: PhoneType
}

input PhoneUpdateWithWhereUniqueWithoutProfileInput {
  data: PhoneUpdateWithoutProfileDataInput!
  where: PhoneWhereUniqueInput!
}

input PhoneUpsertWithWhereUniqueWithoutProfileInput {
  create: PhoneCreateWithoutProfileInput!
  update: PhoneUpdateWithoutProfileDataInput!
  where: PhoneWhereUniqueInput!
}

input PhoneWhereInput {
  AND: [PhoneWhereInput!]
  id: IntFilter
  NOT: [PhoneWhereInput!]
  number: StringFilter
  OR: [PhoneWhereInput!]
  profile: ProfileWhereInput
  profileId: IntFilter
  type: PhoneType
}

input PhoneWhereUniqueInput {
  id: Int
}

type Profile {
  companyName: String
  id: Int!
  user: User!
  userId: Int!
  website: String
}

input ProfileCreateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateWithoutUserInput {
  companyName: String
  companyRole: String
  phone: PhoneCreateManyWithoutProfileInput
  updatedAt: DateTime
  website: String
}

input ProfileUpdateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserDataInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserDataInput {
  companyName: String
  companyRole: String
  id: Int
  phone: PhoneUpdateManyWithoutProfileInput
  updatedAt: DateTime
  website: String
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  companyName: NullableStringFilter
  companyRole: NullableStringFilter
  id: IntFilter
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  phone: PhoneFilter
  updatedAt: NullableDateTimeFilter
  user: UserWhereInput
  userId: IntFilter
  website: NullableStringFilter
}

input ProfileWhereUniqueInput {
  id: Int
}

type Query {
  allCollections(after: CollectionWhereUniqueInput, before: CollectionWhereUniqueInput, first: Int, last: Int, orderBy: CollectionOrderByInput, skip: Int, where: CollectionWhereInput): [Collection!]!
  allUsers(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  allWorks(after: WorkWhereUniqueInput, before: WorkWhereUniqueInput, first: Int, last: Int, orderBy: WorkOrderByInput, skip: Int, where: WorkWhereInput): [Work!]!
  collection(where: CollectionWhereUniqueInput!): Collection
  empty: Boolean
  me: User
  work(where: WorkWhereUniqueInput!): Work
  worksByCollection(after: Int, before: Int, first: Int, last: Int, orderBy: WorkOrderByInput, skip: Int, where: CollectionWhereInput): Collection!
}

enum Role {
  ADMIN
  MANAGER
  SUPER
  USER
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum Type {
  MIXED
  PAINTING
  SCULPTURE
}

type User {
  collections(after: CollectionWhereUniqueInput, before: CollectionWhereUniqueInput, first: Int, last: Int, skip: Int): [Collection!]!
  display: String
  email: String!
  id: Int!
  profile: Profile
  role: Role!
  username: String!
}

input UserCreateManyWithoutCollectionsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCollectionsInput!]
}

input UserCreateWithoutCollectionsInput {
  createdAt: DateTime
  display: String
  email: String!
  password: String!
  profile: ProfileCreateOneWithoutUserInput
  role: Role
  updatedAt: DateTime
  username: String!
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  createdAt: OrderByArg
  display: OrderByArg
  email: OrderByArg
  id: OrderByArg
  password: OrderByArg
  role: OrderByArg
  updatedAt: OrderByArg
  username: OrderByArg
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  collections: CollectionFilter
  createdAt: DateTimeFilter
  display: NullableStringFilter
  email: StringFilter
  id: IntFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  role: Role
  updatedAt: NullableDateTimeFilter
  username: StringFilter
}

input UserUpdateManyDataInput {
  createdAt: DateTime
  display: String
  email: String
  id: Int
  password: String
  role: Role
  updatedAt: DateTime
  username: String
}

input UserUpdateManyWithoutCollectionsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCollectionsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCollectionsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCollectionsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutCollectionsDataInput {
  createdAt: DateTime
  display: String
  email: String
  id: Int
  password: String
  profile: ProfileUpdateOneWithoutUserInput
  role: Role
  updatedAt: DateTime
  username: String
}

input UserUpdateWithWhereUniqueWithoutCollectionsInput {
  data: UserUpdateWithoutCollectionsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutCollectionsInput {
  create: UserCreateWithoutCollectionsInput!
  update: UserUpdateWithoutCollectionsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  collections: CollectionFilter
  createdAt: DateTimeFilter
  display: NullableStringFilter
  email: StringFilter
  id: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  profile: ProfileWhereInput
  role: Role
  updatedAt: NullableDateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  username: String
}

type Work {
  catalogId: Int!
  category: Category!
  collections(after: CollectionWhereUniqueInput, before: CollectionWhereUniqueInput, first: Int, last: Int, skip: Int, where: CollectionWhereInput): [Collection!]!
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int!
  medium: String
  price: Float
  title: String!
  type: Type!
  width: Float
  workOrder(after: WorkOrderWhereUniqueInput, before: WorkOrderWhereUniqueInput, first: Int, last: Int, orderBy: WorkOrderOrderByInput, skip: Int): [WorkOrder!]!
}

type WorkConnection {
  cursor: String
  hasMore: Boolean!
  works: [Work]!
}

input WorkCreateInput {
  catalogId: Int!
  category: Category
  collections: CollectionCreateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
  workOrder: WorkOrderCreateManyWithoutWorkInput
}

input WorkCreateManyWithoutCollectionsInput {
  connect: [WorkWhereUniqueInput!]
  create: [WorkCreateWithoutCollectionsInput!]
}

input WorkCreateOneWithoutWorkOrderInput {
  connect: WorkWhereUniqueInput
  create: WorkCreateWithoutWorkOrderInput
}

input WorkCreateWithoutCollectionsInput {
  catalogId: Int!
  category: Category
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
  workOrder: WorkOrderCreateManyWithoutWorkInput
}

input WorkCreateWithoutWorkOrderInput {
  catalogId: Int!
  category: Category
  collections: CollectionCreateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  image: ImageCreateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean!
  title: String!
  type: Type
  updatedAt: DateTime
  width: Float
}

input WorkFilter {
  every: WorkWhereInput
  none: WorkWhereInput
  some: WorkWhereInput
}

type WorkOrder {
  collectionId: Int!
  order: Int!
  workId: Int!
}

input WorkOrderByInput {
  catalogId: OrderByArg
  category: OrderByArg
  createdAt: OrderByArg
  date: OrderByArg
  dimensions: OrderByArg
  framed: OrderByArg
  height: OrderByArg
  id: OrderByArg
  medium: OrderByArg
  price: OrderByArg
  published: OrderByArg
  title: OrderByArg
  type: OrderByArg
  updatedAt: OrderByArg
  width: OrderByArg
}

input WorkOrderCreateManyWithoutCollectionInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutCollectionInput!]
}

input WorkOrderCreateManyWithoutWorkInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutWorkInput!]
}

input WorkOrderCreateWithoutCollectionInput {
  order: Int!
  work: WorkCreateOneWithoutWorkOrderInput!
}

input WorkOrderCreateWithoutWorkInput {
  collection: CollectionCreateOneWithoutWorkOrderInput!
  order: Int!
}

input WorkOrderFilter {
  every: WorkOrderWhereInput
  none: WorkOrderWhereInput
  some: WorkOrderWhereInput
}

input WorkOrderOrderByInput {
  collection: OrderByArg
  collectionId: OrderByArg
  id: OrderByArg
  order: OrderByArg
  work: OrderByArg
  workId: OrderByArg
}

input WorkOrderScalarWhereInput {
  AND: [WorkOrderScalarWhereInput!]
  collectionId: IntFilter
  id: IntFilter
  NOT: [WorkOrderScalarWhereInput!]
  OR: [WorkOrderScalarWhereInput!]
  order: IntFilter
  workId: IntFilter
}

input WorkOrderUpdateManyDataInput {
  id: Int
  order: Int
}

input WorkOrderUpdateManyWithoutCollectionInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutCollectionInput!]
  delete: [WorkOrderWhereUniqueInput!]
  deleteMany: [WorkOrderScalarWhereInput!]
  disconnect: [WorkOrderWhereUniqueInput!]
  set: [WorkOrderWhereUniqueInput!]
  update: [WorkOrderUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [WorkOrderUpdateManyWithWhereNestedInput!]
  upsert: [WorkOrderUpsertWithWhereUniqueWithoutCollectionInput!]
}

input WorkOrderUpdateManyWithoutWorkInput {
  connect: [WorkOrderWhereUniqueInput!]
  create: [WorkOrderCreateWithoutWorkInput!]
  delete: [WorkOrderWhereUniqueInput!]
  deleteMany: [WorkOrderScalarWhereInput!]
  disconnect: [WorkOrderWhereUniqueInput!]
  set: [WorkOrderWhereUniqueInput!]
  update: [WorkOrderUpdateWithWhereUniqueWithoutWorkInput!]
  updateMany: [WorkOrderUpdateManyWithWhereNestedInput!]
  upsert: [WorkOrderUpsertWithWhereUniqueWithoutWorkInput!]
}

input WorkOrderUpdateManyWithWhereNestedInput {
  data: WorkOrderUpdateManyDataInput!
  where: WorkOrderScalarWhereInput!
}

input WorkOrderUpdateWithoutCollectionDataInput {
  id: Int
  order: Int
  work: WorkUpdateOneRequiredWithoutWorkOrderInput
}

input WorkOrderUpdateWithoutWorkDataInput {
  collection: CollectionUpdateOneRequiredWithoutWorkOrderInput
  id: Int
  order: Int
}

input WorkOrderUpdateWithWhereUniqueWithoutCollectionInput {
  data: WorkOrderUpdateWithoutCollectionDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpdateWithWhereUniqueWithoutWorkInput {
  data: WorkOrderUpdateWithoutWorkDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpsertWithWhereUniqueWithoutCollectionInput {
  create: WorkOrderCreateWithoutCollectionInput!
  update: WorkOrderUpdateWithoutCollectionDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderUpsertWithWhereUniqueWithoutWorkInput {
  create: WorkOrderCreateWithoutWorkInput!
  update: WorkOrderUpdateWithoutWorkDataInput!
  where: WorkOrderWhereUniqueInput!
}

input WorkOrderWhereInput {
  AND: [WorkOrderWhereInput!]
  collection: CollectionWhereInput
  collectionId: IntFilter
  id: IntFilter
  NOT: [WorkOrderWhereInput!]
  OR: [WorkOrderWhereInput!]
  order: IntFilter
  work: WorkWhereInput
  workId: IntFilter
}

input WorkOrderWhereUniqueInput {
  id: Int
}

input WorkScalarWhereInput {
  AND: [WorkScalarWhereInput!]
  catalogId: IntFilter
  category: Category
  collections: CollectionFilter
  createdAt: DateTimeFilter
  date: NullableStringFilter
  dimensions: NullableStringFilter
  framed: NullableBooleanFilter
  height: NullableFloatFilter
  id: IntFilter
  image: ImageFilter
  medium: NullableStringFilter
  NOT: [WorkScalarWhereInput!]
  OR: [WorkScalarWhereInput!]
  price: NullableFloatFilter
  published: BooleanFilter
  title: StringFilter
  type: Type
  updatedAt: NullableDateTimeFilter
  width: NullableFloatFilter
  workOrder: WorkOrderFilter
}

input WorkUpdateInput {
  catalogId: Int
  category: Category
  collections: CollectionUpdateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int
  image: ImageUpdateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean
  title: String
  type: Type
  updatedAt: DateTime
  width: Float
  workOrder: WorkOrderUpdateManyWithoutWorkInput
}

input WorkUpdateManyDataInput {
  catalogId: Int
  category: Category
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int
  medium: String
  price: Float
  published: Boolean
  title: String
  type: Type
  updatedAt: DateTime
  width: Float
}

input WorkUpdateManyWithoutCollectionsInput {
  connect: [WorkWhereUniqueInput!]
  create: [WorkCreateWithoutCollectionsInput!]
  delete: [WorkWhereUniqueInput!]
  deleteMany: [WorkScalarWhereInput!]
  disconnect: [WorkWhereUniqueInput!]
  set: [WorkWhereUniqueInput!]
  update: [WorkUpdateWithWhereUniqueWithoutCollectionsInput!]
  updateMany: [WorkUpdateManyWithWhereNestedInput!]
  upsert: [WorkUpsertWithWhereUniqueWithoutCollectionsInput!]
}

input WorkUpdateManyWithWhereNestedInput {
  data: WorkUpdateManyDataInput!
  where: WorkScalarWhereInput!
}

input WorkUpdateOneRequiredWithoutWorkOrderInput {
  connect: WorkWhereUniqueInput
  create: WorkCreateWithoutWorkOrderInput
  update: WorkUpdateWithoutWorkOrderDataInput
  upsert: WorkUpsertWithoutWorkOrderInput
}

input WorkUpdateWithoutCollectionsDataInput {
  catalogId: Int
  category: Category
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int
  image: ImageUpdateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean
  title: String
  type: Type
  updatedAt: DateTime
  width: Float
  workOrder: WorkOrderUpdateManyWithoutWorkInput
}

input WorkUpdateWithoutWorkOrderDataInput {
  catalogId: Int
  category: Category
  collections: CollectionUpdateManyWithoutWorksInput
  createdAt: DateTime
  date: String
  dimensions: String
  framed: Boolean
  height: Float
  id: Int
  image: ImageUpdateManyWithoutWorkInput
  medium: String
  price: Float
  published: Boolean
  title: String
  type: Type
  updatedAt: DateTime
  width: Float
}

input WorkUpdateWithWhereUniqueWithoutCollectionsInput {
  data: WorkUpdateWithoutCollectionsDataInput!
  where: WorkWhereUniqueInput!
}

input WorkUpsertWithoutWorkOrderInput {
  create: WorkCreateWithoutWorkOrderInput!
  update: WorkUpdateWithoutWorkOrderDataInput!
}

input WorkUpsertWithWhereUniqueWithoutCollectionsInput {
  create: WorkCreateWithoutCollectionsInput!
  update: WorkUpdateWithoutCollectionsDataInput!
  where: WorkWhereUniqueInput!
}

input WorkWhereInput {
  AND: [WorkWhereInput!]
  catalogId: IntFilter
  category: Category
  collections: CollectionFilter
  createdAt: DateTimeFilter
  date: NullableStringFilter
  dimensions: NullableStringFilter
  framed: NullableBooleanFilter
  height: NullableFloatFilter
  id: IntFilter
  image: ImageFilter
  medium: NullableStringFilter
  NOT: [WorkWhereInput!]
  OR: [WorkWhereInput!]
  price: NullableFloatFilter
  published: BooleanFilter
  title: StringFilter
  type: Type
  updatedAt: NullableDateTimeFilter
  width: NullableFloatFilter
  workOrder: WorkOrderFilter
}

input WorkWhereUniqueInput {
  catalogId: Int
  id: Int
}
